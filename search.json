[{"title":"2025-8-18 v2.0 Changelog","url":"/2025/08/18/changelog2/","content":"经过一段时间的修修补补，这个博客网站终于迎来了 2.0 版本。\n下面是一些具体的说明。\n新功能&#x2F;What’s New新增特点&#x2F;New Features\n新增“关于”页面\n\n\n\n新增了相关文章推荐部分\n\n\n\n新增了英语和日语门户网站（请注意，英语站点使用的主题和中文、日文不同）\n\n\n\n改动部分&#x2F;Changed\n为更好地美化网站以及适应国际化需求，博客的主题从 Redefine 2.8.5 更改为 Butterfly 5.4.3\n\n\n错误修复&#x2F;Bug Fix\n修正某些文章内存在的错误内容\n修复在进行 git 提交时，改动的内容在部署的目标网站上不显示的问题\n修复在使用新主题时，友情链接页面无法打开的问题\n\n关于国际化这里采用的方案是不同语言使用不同的存储库，最后再通过下拉式菜单的链接跳转。虽然这不是最优解，但总比费半天心思折腾 source 文件夹的内容还要加一大堆 JavaScript 要好得多。另一大优势是我们可以为不同语言的地区指定主题，这样更加能够符合来自不同国家&#x2F;地区的人（例如欧美人）的品味。\n","categories":["changelog"],"tags":["changelog"]},{"title":"2025-9-2 v3.0 Changelog","url":"/2025/09/22/changelog3/","content":"经过叒叒叒一段时间的努力，网站的 3.0 版本终于和各位见面了。\n下面是一些具体的说明。\n新功能&#x2F;What’s New新增特点&#x2F;New Features\n在网站底部新增了运行时间\n\n\n\n新增了多种文字效果：下划线、着重号、波浪线、删除线、键盘、密码样式文本（参考这篇博客）\n\n开放了评论区，目前支持 Twikoo 和 Giscus\n\n\n\n\n改动部分&#x2F;Changed\n更换了首页的铸币大头照\n\n\n\n去掉了点击出现文字的特效（干扰复制）\n\n错误修复&#x2F;Bug Fix\n修正某些文章内存在的错误内容\n修复运行时间无法正确显示的问题\n修复密码样式的文本无法被完全覆盖的问题\n\n即将引入&#x2F;Upcoming Features\n 基于 Aplayer 的音乐播放器\n 新版导航栏\n Element UI 和 Emoji\n Github Badge\n\n关于英语站点的重要通知由于本人学业和技术原因，英语站点即将停止更新，恢复时间另行通知。届时将迁移至 WordPress 框架。\n","categories":["changelog"],"tags":["changelog"]},{"title":"Debian 13 升级指南","url":"/2025/08/11/debian-13/","content":"废话部分2025 年 8 月 9 日，万众期待的 Debian 13 Trixie 总算是“千呼万唤始出来”，带着全新的 6.12 LTS 内核、GNOME 48以及一众版本几乎为最新的软件包亮相。这使得 Debian 不仅在稳定性上延续了它一贯的口碑，也在硬件支持、性能优化和桌面体验上向前迈出了一大步。对许多开发者、服务器运维人员以及桌面用户来说，这次升级意味着更好的硬件兼容性、更长的安全维护周期，以及更多新功能可供探索。\n在这篇文章中，我将详细讲述如何顺利地从 Debian 12 Bookworm 升级到 Debian 13 Trixie，在享受新功能的同时最大程度的规避风险。\n前提条件在进行升级前，确保当前系统具有以下条件：\n\n最低 5 GB 的可用硬盘空间\n至少 512 MB 内存\namd64 或 arm64 等官方支持架构的 CPU\n良好的网络连接\n\n如果你还没有安装 Debian 12，那就可以跳过本文直接去安装 Debian 13 了。但是你也可以选择看完\n\n从 Debian 13 Trixie 开始，i386（32位）架构已经不再正式被官方支持，对于仍然需要使用 i386 架构的用户，可以考虑使用其他支持该架构的 Linux 发行版或不进行后续升级。当然你要是能魔改系统就当我没说\n\n整个升级过程涉及到内核更新，一旦更新过程被打断会导致系统无法启动或正常运行。此外，请务必禁用系统休眠，否则会导致更新不完整甚至被直接中断。\n\n在更新之前，确保你与服务器的网络连接正常，如果无线网络质量很差，请换个地方再试一次。若条件允许，建议使用以太网或有线连接。对于身处中国大陆地区的用户，请将软件源修改为当地镜像源（例如清华源等）以加速下载过程。具体步骤请参阅官方说明。可以使用如下命令测试你与服务器的连通性：\n\n\nping www.debian.org # 按下 Ctrl + C 以中止\n\n升级前的准备备份重要数据（可选）这一步需要使用 rsync, tar 或 BorgBackup 等工具。当然如果你使用的是 ext4 文件系统，timeshift 也行。具体的操作步骤请参阅官方手册。但是用 btrfs 的还是老老实实地用专业工具吧，你的 timeshift 或 btrfs-assistant 快照全在同一个硬盘上，一旦硬盘磁道或者颗粒挂了就老实了\n更新软件源运行 sudo apt update 更新软件源并获取新的软件版本。\n从 Debian 13 开始，软件源配置文件将全面采用新的 DEB822 格式，路径从原来的 /etc/apt/sources.list 更改为 /etc/apt/sources.list.d/debian.sources。这一点在大家熟悉的 Ubuntu 24.04 LTS 以后版本已经有所体现。\n\n\n\nDebian 12 原生不支持如下命令：sudo apt modernize-sources凡是在教程中让你在 Debian 12 下使用这个命令去改变软件源配置文件格式的，都是误人子弟的家伙！\n\n\n在该操作结束后，如果出现如下错误信息：\n\n就说明当前 Debian 12 软件源配置文件用的还是 Bookworm 的（因为软件源仓库返回的信息说明 Bookworm 现在已经成为旧稳定版，而系统仍然认为它是当前稳定版）。要解决这一问题，我们需要使用 sed 来自动替换文本（需要 sudo 权限）：\nsed -i &#x27;s/bookworm/trixie/g&#x27; /etc/apt/sources.list# 如果使用的是 DEB822 格式的配置文件sed -i &#x27;s/bookworm/trixie/g&#x27; /etc/apt/sources.list.d/*.listsed -i &#x27;s/bookworm/trixie/g&#x27; /etc/apt/sources.list.d/*.sources\n后面两个提示 no matches found: xxx 的可以暂时不用替换。\n\n\n这一步会将 /etc/apt/sources.list, /etc/apt/sources.list.d/*.list 和 /etc/apt/sources.list.d/*.sources 配置文件下所有匹配 bookworm 的字符串全部替换为 trixie，以便能使用当前版本的软件源仓库。\n另一种方式是手动编辑：\nsudo apt edit-sources\n\n用 vim 或者 nano 这样的文件编辑器完成这一步也可以。就是有亿点麻烦\n如果你已经事先将传统的配置文件手动替换为新版的 DEB822 格式，那么你可以安全删除 /etc/apt/sources.list 了。\n\n\n更新系统部分软件包升级我们先在不安装新软件包的情况下，对部分软件包进行升级：\nsudo apt updatesudo apt upgrade --without-new-pkgs\n\n这一部分是不会升级 Linux 内核版本的（你看看 Debian 12 默认的内核版本有多老），我们这么做的目的只是为了先检查有没有什么依赖项问题。如果有，运行 sudo apt --fix-broken install 以快速解决。\n\n\n内核升级接下来，我们对整个系统进行大规模升级：\nsudo apt full-upgrade -y\n\n这一步由于需要升级内核，所花费的时间比较长，因此可以暂时放松一下。\n在更新过程中可能会出现以下画面：\n\n这里我们选Yes，然后继续更新过程。\n更新后操作清理无用的软件包等终端不再输出 apt 信息（等待输入命令）后，我们来清理软件源并删除不需要的软件包：\nsudo apt autoremove -y # 删除不需要的软件包（可以加上--purge选项）sudo apt autoclean # 清理软件源\n\n检查当前更新后版本检查一下内核版本和系统版本：\nuname -r # 内核版本lsb_release -a # 系统版本# 或者运行 cat /etc/os-release\n\n输出应该和下面类似：\n\n开始体验新版本重启系统：\nsudo reboot\n\n界面主题应该和下面这张图类似：\n\n\n（为了节省资源，我用的是 Xfce 桌面环境，当然各人用的桌面环境都不一样）\n至此，升级到 Debian 13 Trixie 的工作就正式告一段落了。\n关于下一个 Debian 稳定版Debian 14 的代号已经正式确定为“forky”，但目前对于其将要采用的 LTS 内核和软件包版本等信息，我们不得而知。不过可以确定的几点是：\n\n继续延续 LTS 策略\n\n如同之前的版本一样，Debian 14 仍将提供至少 5 年的安全更新周期，并在此基础上可能引入更新的内核小版本以增强硬件兼容性。\n\n支持更新的硬件架构\n\n预计将更好地支持新一代 x86_64-v3 指令集，以及 ARM 平台上的最新 SoC，为桌面和服务器设备提供更高性能。\n\n桌面环境版本升级\n\nGNOME、KDE Plasma、Xfce 等主流桌面环境将会跟进上游的主要版本，带来新的功能和界面改进。\n\n软件包清理与替换\n\n一些已不再维护或安全风险较高的软件包将会被移除，并引入更现代的替代方案。\n\n安装与配置体验优化\n\nCalamares、Debian Installer 等安装工具将获得更多改进（目前已经增加教育版、天文版等其他版本），以降低新用户的安装门槛并使用户群体多元化。\n参考https://fullmetalbrackets.com/blog/upgrade-debian-12-bookworm-debian-13-trixie/\nhttps://stackoverflow.com/questions/68802802/repository-http-security-debian-org-debian-security-buster-updates-inrelease\n","categories":["Linux","Debian"],"tags":["Linux","Debian"]},{"title":"2025-8-9 v1.0 Changelog","url":"/2025/08/09/first-blog/","content":"这是自建站以来的第一篇博客。由于建站过程很累，而且中途差错不断，我就简单说几点网站内容和遇到的困难，就权且当做是一个网站测试吧。\n之后每次大版本更新完都会发布一个 Changelog，以展示新功能、错误修复和一些细节上的优化。\n（你们估计要吐槽白天模式下中间的字看不清楚，是的，我一直在改背景图片的曝光度，但是改来改去也就这个样，很难达到夜晚模式下的效果，所以干脆直接摆烂了。另外，伊吹酱可爱捏）\n新功能&#x2F;What’s New新增特点&#x2F;New Features\n使用 Hexo 7.3.0 搭建博客框架，以及 Redefine 2.8.5 作为主题。\n\n\n\n新增了“分类”、“友情链接”和“标签”页面，方便查找博客内容以及列出参考的其他博客网站等。别问我为什么加顿号\n\n\n错误修复&#x2F;Bug Fix\n修复在 Firefox 内网页渲染异常错误的问题\n修复在“链接”子菜单内打开相应链接时页面提示 404 的问题\n\n关于博客这个博客是干什么的？正如网站横幅标题所要展现的，“Linux and You”。因此，这个博客主要是一些关于 Linux 的内容，当然也有可能会随机刷新诸如 C/C++ 或者Python之类的文章。\n你是怎么搭建起这个博客的？一开始我用的是 ClawCloud 的云服务（毕竟它的价格非常诱人，Github 老用户还送 $5 免费额度），但是在过了两天之后，博客文件所在的 pod 一直显示 Pending（崩了），重启数次也无果（白忙了 2 天……），于是一怒之下直接删库跑路。\n在对比了多家云服务商后，我发现 Azure 和 AWS 费用高的吓人，界面也很难操作；Google 的费用相对低很多，但是有着潜在的隐私问题。你也不想你的个人信息被一家广告商拿去用来盈利吧\n最后，我决定考虑 Github 。由于 Vercel 在某些国家&#x2F;地区被墙（你可以用某些特殊手段），我采用 Github 和 Netlify 的方式部署，目前一直没出什么差错。\n建站时出现过哪些问题？除了之前在“错误修复”和上面部分提到的问题以外，还出现过以下问题：\n\n分支填错。初始分支是 main，我记成了 master（后来被我删了），导致 VSCode 内 Git 的 master 分支像幽灵一样一直跑不掉，最后只能删库从头再来。（好在还没有做什么配置）\n中日韩文字乱码，甚至渲染异常。找了一圈最后才发现是我 VSCode 用的是 GBK 而不是 UTF-8 编码导致的。\n\n其他的一些次要问题和不可抗力因素（比如说上课），这里就不一一展开了。\n博客将会采用哪种更新计划？博客将采用类似 Debian 和 Ubuntu 的稳定版本更新策略，而非滚动更新。如果采用滚动更新模式，可能会导致以下问题：\n\nGit 提交过于频繁，使得版本历史杂乱，难以管理。\n难以敲定新版本的功能，因为持续的小幅更新可能缺乏明确的阶段性目标。\n时间问题，频繁更新会增加维护成本，而稳定版本能更好地平衡更新节奏与内容质量。\n\n因此，博客会不定期（不是像滚动更新那样）发布经过测试和完善的版本，确保每次更新都带来稳定的体验。\n博客内的文章会有什么提醒或说明部分吗？有。视内容程度，分为以下三种：\n\n说明&#x2F;提示\n\n表示对当前内容的补充说明或关联信息提示。\nCinnamon 桌面环境其实是 GNOME 3 的分支。\n\n\n\n提醒&#x2F;注意\n\n表示在当前环境下建议（非强制）进行的操作，或者需要注意的事项。\nC&#x2F;C++ 编译器不会进行运行时检查，因此一旦出现数组越界或堆栈溢出等问题将导致程序闪退。\n\n\n\n警告&#x2F;禁止\n\n表示在当前环境下必须（强制）或绝对禁止进行的操作，或者某一项操作可能对系统或硬件引起的不可逆损害。\n有时也可能是为了占坑用，表示该部分内容仍在编写中，暂时不可访问。\n格式化硬盘会抹掉目标硬盘上所有分区的数据！！\n\n\n后续的新功能\n 新增“关于”页面\n 在底部增加文章推荐部分以快速跳转\n 重新整理导航栏的内容\n 增加评论功能\n\n","categories":["changelog"],"tags":["changelog"]},{"title":"gtkmm 教程（1）—— gtkmm 的安装与使用","url":"/2025/08/23/gtkmm-note1-installation/","content":"GTK 是由 GNOME 官方推出的 GNOME 桌面环境应用程序开发包。它基于事件驱动，在执行时，会监听应用程序内发生的事件，例如单击鼠标，改变窗体大小，再向应用程序内的组件告知信息。\nGTK 支持 C, JavaScript, Python, Rust 等多种语言（你猜为什么没有 Java）。然而，从网页上给出的示例代码来看，本人相对熟悉的 C 语言实现版本较为复杂，而 Python 相对简单，却并非本文所探讨的范畴（你看，分类写的是 C++，所以不会有 Python）。因此，我们这里选用语法风格更像 C++ 的扩展包，也就是 gtkmm 作为这个系列的开发工具包。\n开始之前这个系列使用的默认开发环境如下：\n\n\n\n名称\n版本\n\n\n\nManjaro\n25\n\n\ngtkmm\n4.0\n\n\nCLion\n2025.2\n\n\n补充：\n\n如果你习惯使用 Ubuntu 或者其他发行版也是可以的！这里不做强制要求！这个系列只是以 Manjaro 为例！（注意，macOS 不支持）\n\n如果你对 C++ 的语法规则不熟悉，请先阅读 C++ 教程 。这个系列至少需要你学会 OOP 中的继承部分。\n\n\n安装 gtkmm在 Manjaro 上安装 gtkmm 的过程非常简单，只需要一行命令：\nsudo pacman -S gtkmm-4.0\n\n在其他系列的发行版上安装 gtkmm 的命令如下：\nDebianFedorasudo apt install libgtkmm-4.0-devsudo dnf install gtkmm-4.0-dev\n\n某些发行版上相对应的名称和将要安装的软件包版本可能有所不同。\n例如，在 Arch Linux 系的发行版中，该软件包有 gtkmm 和 gtkmm-4.0 两个版本，它们所指向的 gtkmm 版本是不一样的！这一点可以通过检查比对依赖项版本得出。\n\n\n一般来说，发行版提供的包管理器都会自动帮我们安装好依赖项。为了方便大家对比，这里列出几个作为参考：\n\n第一个项目代码实现打开任意一个代码编辑器（这里我用的是 CLion，其他编辑器也行），创建一个名为 main.cpp 的源文件，并输入（或复制粘贴）以下内容：\n// It&#x27;s OK if you want some other cool names// This depends on you!#include &lt;gtkmm.h&gt;#include &lt;iostream&gt;// Custom GTK Window Class.class CustomGTKWindow : public Gtk::Window &#123;public:    CustomGTKWindow(); // Constructor&#125;;CustomGTKWindow::CustomGTKWindow() &#123;    set_title(&quot;Hello World&quot;); // set default title    set_default_size(800, 600); // set height and width of the window&#125;// As you can see this one is much simpler than WinMain and even Qt.int main(int argc, char *argv[]) &#123;    auto lang = &quot;C++&quot;;    std::cout &lt;&lt; &quot;Hello and welcome to &quot; &lt;&lt; lang &lt;&lt; &quot;!\\n&quot;;    auto app = Gtk::Application::create(&quot;org.gtkmm.examples.hello_world&quot;);    return app-&gt;make_window_and_run&lt;CustomGTKWindow&gt;(argc, argv);&#125;\n\n（原教程使用 .cc 作为源文件后缀名。.cc 是一种在 Linux&#x2F;UNIX 系统上广泛使用的 C++ 源文件格式，对该类系统的优化较好。但这里为了更广泛的兼容性，我们仍然采用传统的 .cpp 后缀名。）\n如果你的 IDE 内出现以下报错：\n\n请打开同一目录下的 CMakeLists.txt，将里面的内容修改为下面的代码片段：\ncmake_minimum_required(VERSION 4.0) # change if there is a newer versionproject(hello_world) # replace it with your nameset(CMAKE_CXX_STANDARD 20) # use your own C++ standard, but make sure no earlier than C++ 17find_package(PkgConfig)pkg_check_modules(GTKMM gtkmm-4.0) # Not gtkmm-3.0!include_directories($&#123;GTKMM_INCLUDE_DIRS&#125;)link_directories($&#123;GTKMM_LIBRARY_DIRS&#125;)# set(SOURCE_FILES main.cpp MainWindow.cpp MainWindow.h)add_executable(hello_world main.cpp) # replace it with your nametarget_link_libraries($&#123;CMAKE_PROJECT_NAME&#125; $&#123;GTKMM_LIBRARIES&#125;)\n\n然后重启 IDE. 问题应该可以得到解决。\n具体可以参考一下这个链接：StackOverflow\n\n\n结果与解释接下来，我们来编译并运行程序。得到的结果应该和下面相似：\n\n（请注意，如果你用的是 GNOME 桌面环境，那么样式应该和 Adwaita 类似）\n这是因为我们目前只是添加了一个窗口标题并设定了宽和高。我们先来看看这段代码的含义：\n#include &lt;gtkmm.h&gt;\n\n它表示导入 gtkmm.h 库。这对于使用 gtkmm 构建的应用来说是必需的。但是严格意义上说，直接使用这个头文件并不是一个好主意——它含有 1 M 左右大小的标头！很显然这会拖慢编译速度。\n下面来看代码最主要的部分，也就是 CustomGTKWindow 类。\n// Custom GTK Window Class.class CustomGTKWindow : public Gtk::Window &#123;public:    CustomGTKWindow(); // Constructor&#125;;CustomGTKWindow::CustomGTKWindow() &#123;    set_title(&quot;Hello World&quot;); // set default title    set_default_size(800, 600); // set height and width of the window&#125;\n\n同样地，这个类也是必需的。它必须继承自命名空间（你可以把它理解为和 std 一个效力的东西）Gtk 中定义的类 Window，并且有一个构造函数（析构函数可以不写）。下面构造函数的实现部分则详细展示了初始化窗体时，对窗体进行初步配置的代码。函数很好理解，我就不过多介绍了。\n最后，在 main 函数内：\nauto app = Gtk::Application::create(&quot;org.gtkmm.examples.hello_world&quot;);return app-&gt;make_window_and_run&lt;CustomGTKWindow&gt;(argc, argv);\n\n它们的作用是创建并初始化窗体对象，这个过程会调用类的构造函数。\n更详细一点说（内容修改自机翻）：程序首先创建的是一个存储在 Glib::RefPtr 智能指针（这是 C++ 11 引入的新特性，相较于传统指针更具有内存安全性）内的 Gtk::Application 对象。create() 方法会初始化 gtkmm。接下来，程序会创建并显示一个窗口并进入 gtkmm 主处理循环（这一点和 tkinter 类似！），该循环将在窗口关闭时完成。然后，main() 函数将返回适当的成功或错误代码。如果从命令行执行程序，argc 和 argv 参数会作为额外参数传递给应用程序。此外在调用 make_window_and_run() 时，系统会检查这两个参数，但今天我们写的这个简单的应用程序并不会使用它们。\n结语至此，你已经成功完成了第一步——创建一个简单的 gtkmm 应用程序。虽然开发一个完整的应用并不是一件很容易的事，但最起码我们已经迈出了决定性的一步。现在，你可以休息一下了！\n参考gtkmm Tutorial Chapter 2: Installation\ngtkmm Tutorial Chapter 3: Simple Example\n","categories":["Linux","C++","gtkmm"],"tags":["Linux","C++","gtkmm"]},{"title":"gtkmm 教程（2）—— 简单的组件和信号","url":"/2025/09/15/gtkmm-note2-widgets-and-signals/","content":"首先，很抱歉更新的这么晚。这段时间由于本人学业原因（破课程净讲一大堆没用的东西，还有，谁家好人要求 4 个星期速通 JavaScript 和 RxJS 的？上来就是 arrow functions，说得云里雾里，还好意思嫌讲的太简单了），前前后后鸽了将近一个月的时间，一直没有空写博客，就暂时搁置了博客的更新计划。\n话不多说，让我们开始今天的内容。\n废话部分在 gtkmm 的开发中，组件（widget）是窗体的必要组成部分。但严格地说，组件这个概念非常宽泛——它可以指按钮，复选框，甚至是……用于放置其他组件的容器。对于后者来说，我们称之为不可视组件，它们与可视组件形成层级关系，其目的只是为了便于组织管理其他可视组件。\n在某些系统中，它还有另一个名字：控件（control）。\n另一个必不可少的组成部分是信号（signal）。前一节我们提到过，GTK 是事件驱动型工具包，因此信号的重要性不言而喻。它是指在与窗体内的组件交互（例如单击，双击，长按，滚动等）时，该组件的反应（类似于手部神经末梢接受刺激后神经冲动沿着神经元传递到大脑皮层，然后生物做出反应）。\n简单示例开始之前我们需要使用 gtkmm/button.h 和 gtkmm/window.h 头文件完成这一部分。\n这样的好处是按需导入，避免出现因使用整个 gtkmm.h 而拖慢编译时间的情况。\nGlib::ustring 介绍Glib::ustring 是 gtkmm 内定义的一个数据类型，用法和标准的 std::string 几乎雷同。不同的是，在某些系统内，std::string 中的每个字符最大仅能支持 8 位字节长度的编码（一般来说，中日韩文字需要的编码都超过 8 位），而 Glib::ustring 采用国际惯用的 Unicode 编码（更准确的说，应该是 UTF-8），可以有效避免这一情况。\n实现简单组件对于初学者而言，我们会将窗体类和 main 函数放在一个文件（或者文件夹）中。但是在实际的生产环境下，为了方便管理代码，并防止 main.cpp 过大导致难以搜索，更加推荐的做法是将类函数及其方法实现分别放在一个头文件和一个 .cpp 文件中（请注意，源文件必须与头文件同名）。\n例如，我们可以使用下面的文件目录结构来存放头文件和源代码：\nxxx (Project Name) ├─include │    ├─header_a.h │    └─... │ ├─src │  ├─header_a.cpp │  └─... │ ├─tests │   ├─test_a.cpp │   └─... (Other test files/framework configurations) │ ├─... (Other files/folders) ├─.gitignore ├─main.cpp ├─CMakeLists.txt └─README.md\n请注意，这并非是唯一解，只要符合规范即可。\n接下来，我们先在 include/helloworld.h 中定义一个窗口：\n#ifndef HELLOWORLD_H#define HELLOWORLD_H// In some IDEs, we may use #pragma once, and without #endif#include &lt;gtkmm/button.h&gt;#include &lt;gtkmm/window.h&gt;// Just include what you really need, like in Pythonclass HelloWorld : public Gtk::Window &#123;public:    HelloWorld();    ~HelloWorld() override;protected:    // Signal handlers:    void on_button_clicked();    // Member widgets:    Gtk::Button m_button;&#125;;#endif // HELLOWORLD_H\n\n在 src/helloworld.cpp 中实现这个类的方法：\n#include &quot;../include/helloworld.h&quot;#include &lt;iostream&gt;// Create a new button with label &quot;Hello World&quot;HelloWorld::HelloWorld(): m_button(&quot;Hello World&quot;) &#123;    // set the margin around the button    m_button.set_margin(10);    // packs the button into the window    set_child(m_button);    set_title(&quot;Hello World&quot;);    set_default_size(200, 120);&#125;// Destructor (Do nothing by default)HelloWorld::~HelloWorld() &#123;&#125;// This must be defined for binding event to the buttonvoid HelloWorld::on_button_clicked() &#123;    std::cout &lt;&lt; &quot;Hello World\\n&quot;;&#125;;\n\n记得更新 CMakeLists.txt（其实 CLion 会自动完成这些）。\n绑定信号要绑定信号，我们需要使用 connect 函数。顾名思义，它的作用是将某个信号和相应的信号处理程序（或者说是结果，这是我胡乱编的）绑定在一起。\n它的用法如下：\n// IMPORTANT: bind the event to the buttonm_button.signal_clicked().connect(sigc::mem_fun(*this,    &amp;HelloWorld::on_button_clicked));\n\n其中，signal_clicked() 指的是按下某个按钮时的触发的信号。至于后面的 sigc::mem_fun 函数，官方的解释比较复杂看不懂就对了，我也看不懂，当然我们在使用的时候只需要记住它的用法：对象本身 *this + 目标函数（例如上面的 on_button_clicked，注意此时没有传入参数，不需要加括号）。\n如果方法内有参数或者方法声明为 static 类型，最有效的方式是采用 C++ 11 引入的 Lambda 包装器：\n// Assume filepath is std::string and already existsm_button.signal_clicked().connect(    [filepath]() &#123;        CustomUserInfoWindow::export_userinfo(filepath);    &#125;);\n\n这样既能保证在某些情况下包含必须的参数，又能在无参数或非 static 类型时使用（此时用于捕获外部变量的 [] 需留空），非常灵活。这也是在 gtkmm 开发中常用的方式。\n接下来，我们将代码加入到上面的 helloworld.cpp 内：\n#include &quot;../include/helloworld.h&quot;#include &lt;iostream&gt;// Create a new button with label &quot;Hello World&quot;HelloWorld::HelloWorld(): m_button(&quot;Hello World&quot;) &#123;    // set the margin around the button    m_button.set_margin(10);    // IMPORTANT: bind the event to the button    m_button.signal_clicked().connect(        []() &#123;            HelloWorld::on_button_clicked();        &#125;    );    // packs the button into the window    set_child(m_button);    set_title(&quot;Hello World&quot;);    set_default_size(200, 120);&#125;// Destructor (Do nothing by default)HelloWorld::~HelloWorld() &#123;&#125;// This must be defined for binding event to the buttonvoid HelloWorld::on_button_clicked() &#123;    std::cout &lt;&lt; &quot;Hello World\\n&quot;;&#125;;\n\n请注意，如果 connect 函数缺失或参数有问题，按下按钮是不会有任何反应的，包括在控制台内！\n运行程序先完成 main.cpp：（不要管注释，我复用的之前的代码，因为我懒）\n#include &lt;gtkmm/application.h&gt;#include &quot;include/helloworld.h&quot;// As you can see this one is much simpler than WinMain and even Qt.int main(int argc, char *argv[]) &#123;    auto app = Gtk::Application::create(&quot;org.gtkmm.examples.hello_world&quot;);    return app-&gt;make_window_and_run&lt;HelloWorld&gt;(argc, argv);&#125;\n\n编译运行代码，不出意外的话会出现这个界面：\n\n单击按钮，在控制台内应该会有信息：上面的 MESA-INTEL 警告信息不用管，这是因为开发者还没有实现这些功能。\n但是，如果你的控制台内出现了如下警告：\nGtk-WARNING **: 23:40:39.776: Unknown key gtk-modules in /home/$USER/.config/gtk-4.0/settings.ini\n是因为系统在安装 gtkmm 时错误地在 GTK 4 的配置文件中加入了某些目前已经被弃用的 GTK 3 配置信息。\n要修复这一问题，请按照路径打开 settings.ini 文件，删除或注释掉这一行：\n#gtk-modules=colorreload-gtk-module:window-decorations-gtk-module\n\n这样再次编译运行时，警告就不会再次出现了。\n如果单击一次按钮后，出现了一次“Hello World”信息，那么恭喜，你已经完成了绝大部分内容！\n综合使用这里，我们实现一个在单击按钮后，导出当前时间日期、登录用户名和 tty 终端名称为文件的简单应用程序。\n背景知识获取时间和日期在 C++ 中，chrono 和 ctime 头文件可用于获取当前时间和日期。例如：\n// get current time point (not a string of time)auto now = std::chrono::system_clock::now();// convert time_point type to time_tstd::time_t t = std::chrono::system_clock::to_time_t(now);// convert time_t to stringstd::string time_str = std::ctime(&amp;t);\n从上面可以看出，输出时间和日期，最少需要 3 行代码。\n获取当前登录的用户名这个涉及到的函数是 std::getenv，原理是利用系统的环境变量输出。需要导入 cstdlib 头文件。例如：\nconst char* username = std::getenv(&quot;username&quot;);\n或者用 getpwuid(getuid())（需要导入 pwd.h 头文件）获取更完整的信息。\n获取终端路径使用 ttyname(STDIN_FILENO) 可以获取当前终端设备的路径，例如 /dev/pts/0。举个例子：\nconst char* tty = ttyname(STDIN_FILENO);\n特别需要说明的是，使用这个函数需要导入头文件 unistd.h。\n文件读写C++ 内置了文件读写的库，名为 fstream（C 语言中文件读写常用的 FILE* 指针定义于 stdio.h 内，和标准的输入输出函数一个位置但是我们说好了不讲 C 语言的）。使用方式也很简单，如果你熟悉 C++ 默认的输入输出函数，那应该不成问题。\n我们还是看两个例子：\n// Method 1: determine file name when defining the file I/O streamstd::ifstream fin_eg1(&quot;example.txt&quot;);std::string str;fin_eg1 &gt;&gt; str;fin_eg1.close();// Method 2: determine file name later (recommended)std::ifstream fin_eg2;fin_eg2.open(&quot;example.txt&quot;);// (the others remain the same...)fin_eg2.close();\nstd::ofstream 的用法和上面的大同小异，这里就不再赘述了。\n实现步骤按照之前的步骤，我们先实现 userinfo.h 的内容：\n#ifndef USERINFO_H#define USERINFO_H// In some IDEs, this could be #pragma once#include &lt;gtkmm/button.h&gt;#include &lt;gtkmm/window.h&gt;class CustomUserInfoWindow: public Gtk::Window &#123;public:    CustomUserInfoWindow();    ~CustomUserInfoWindow() override;protected:    // Signal Handlers (like on_button_clicked)    static void export_userinfo();    // Member Widgets    Gtk::Button prompt_button;&#125;;#endif //USERINFO_H\n\n接下来，在 useinfo.cpp 内实现方法：\nCustomUserInfoWindow::CustomUserInfoWindow():    prompt_button(&quot;Get User Info&quot;) &#123;    // set the margin around the button    prompt_button.set_margin(10);    // IMPORTANT: bind the event to the button    prompt_button.signal_clicked().connect(        []() &#123;            CustomUserInfoWindow::export_userinfo();        &#125;);    // packs the button into the window    set_child(prompt_button);    set_title(&quot;Hello World&quot;);    set_default_size(200, 120);&#125;CustomUserInfoWindow::~CustomUserInfoWindow() &#123;&#125;void CustomUserInfoWindow::export_userinfo() &#123;    // get current time point (not a string of time)    auto now = std::chrono::system_clock::now();    // convert time_point type to time_t    std::time_t t = std::chrono::system_clock::to_time_t(now);    // convert time_t to string    std::string time_str = std::ctime(&amp;t);    // get current username    const char* username = getenv(&quot;USER&quot;);    // not username; please use linux env vars    // terminal name (tty)    const char* tty_name = ttyname(STDIN_FILENO);    // make output    std::ofstream fout(&quot;user_info.txt&quot;, std::ios::app);    fout &lt;&lt; &quot;----------------------------------\\n&quot;; // dividing line    fout &lt;&lt; &quot;date: &quot; &lt;&lt; time_str;    fout &lt;&lt; &quot;username: &quot; &lt;&lt; username &lt;&lt; &quot;\\n&quot;;    fout &lt;&lt; &quot;tty_name: &quot; &lt;&lt; tty_name &lt;&lt; &quot;\\n&quot;;    fout &lt;&lt; &quot;----------------------------------\\n&quot;; // dividing line    std::cout &lt;&lt; &quot;User info exported!\\n&quot;;    fout.close();&#125;\n\n最后，在 main.cpp 中：\n#include &quot;include/userinfo.h&quot;#include &lt;gtkmm/application.h&gt;int main(int argc, char *argv[]) &#123;    auto app = Gtk::Application::create(&quot;org.gtkmm.examples.widgets-integrated&quot;);    return app-&gt;make_window_and_run&lt;CustomUserInfoWindow&gt;(argc, argv);&#125;\n\n结果展示编译运行，结果应该是这样的：\n\n单击 “Get User Info”, 我们会在 user_info.txt 内看到如下内容：\n\n\n后续内容下一节，我会深入讲解 Gtk::Button 的内容，和它的几种不同类型，比如 ToggleButton，CheckButton 以及 RadioButton 等。相应的，我也会讲解如何引入自定义的图标，以及如何隐藏窗体的标题栏。\n参考gtkmm Tutorial Chapter 3. Basics: Widgets\ngtkmm Tutorial Chapter 3. Basics: Signals\ngtkmm Tutorial Chapter 3. Basis: Glib::ustring\ngtkmm Tutorial Chapter 3. Basics: Hello World in gtkmm\n","categories":["Linux","C++","gtkmm"],"tags":["Linux","C++,gtkmm"]}]